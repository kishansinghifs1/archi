"""Dataclass to standardize the output of the classic pipelines and the pipelines / agents."""

from dataclasses import dataclass, field, asdict
from typing import Any, Dict, List, Iterator
from langchain_core.documents import Document
from langchain_core.messages import BaseMessage


@dataclass
class PipelineOutput:
    """Standard container for classic pipelines and agent responses."""

    answer: str
    """The final answer content generated by the pipeline or agent."""

    source_documents: List[Document] = field(default_factory=list)
    """The source documents used to generate the answer."""

    messages: List[BaseMessage] = field(default_factory=list)
    """The sequence of messages exchanged during the pipeline or agent execution."""

    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional metadata or structured payloads returned by the pipeline."""

    final: bool = True
    """Indicates whether this object represents the terminal payload in a stream of outputs."""

    def __getitem__(self, key: str) -> Any:
        return self.to_dict()[key]

    def __iter__(self) -> Iterator[str]:
        return iter(self.to_dict())

    def __len__(self) -> int:
        return len(self.to_dict())
    
    def get(self, key: str, default: Any = None) -> Any:
        return self.to_dict().get(key, default)

    def extract_tool_calls(self) -> List[Dict[str, Any]]:
        """Return a normalized list of tool calls extracted from message history."""
        tool_results: Dict[str, Any] = {}
        tool_inputs_by_id: Dict[str, Any] = self.metadata.get("tool_inputs_by_id", {}) if self.metadata else {}
        for msg in self.messages:
            tool_call_id = getattr(msg, "tool_call_id", None)
            if tool_call_id:
                tool_results[tool_call_id] = getattr(msg, "content", "")

        tool_calls: List[Dict[str, Any]] = []
        for msg in self.messages:
            calls = getattr(msg, "tool_calls", None)
            if not calls:
                continue
            for call in calls:
                if isinstance(call, dict):
                    entry = dict(call)
                    tool_call_id = entry.get("id")
                else:
                    tool_call_id = getattr(call, "id", None)
                    entry = {
                        "name": getattr(call, "name", None),
                        "args": getattr(call, "args", None),
                        "id": tool_call_id,
                        "type": getattr(call, "type", None),
                    }
                if tool_call_id and entry.get("args") in (None, "", {}, []):
                    fallback = tool_inputs_by_id.get(tool_call_id, {})
                    if isinstance(fallback, dict):
                        entry["args"] = fallback.get("tool_input", entry.get("args"))
                        if not entry.get("name"):
                            entry["name"] = fallback.get("tool_name", entry.get("name"))
                if tool_call_id and tool_call_id in tool_results:
                    entry["result"] = tool_results[tool_call_id]
                tool_calls.append(entry)
        return tool_calls

    def to_dict(self) -> Dict[str, Any]:
        # asdict handles nested dataclasses too
        return asdict(self)
